CREATE TABLE categories_classifier(
    category_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    category_name VARCHAR(255) NOT NULL
);

CREATE TABLE subcategories_classifier(
    subcategory_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    subcategory_name VARCHAR(255) NOT NULL,

    catogory_id INTEGER         REFERENCES categories_classifier(category_id)
);

CREATE TABLE categories_classifier(
    categories_classifier_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    categories_classifier_name VARCHAR(255) NOT NULL
);

CREATE TABLE currencies_classifier(
    currency_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    currency_name VARCHAR(255) NOT NULL
);

CREATE TABLE personal_info(
    personal_info_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255) NOT NULL,
    middle_name VARCHAR(255),
    phone VARCHAR(12) NOT NULL,
    email VARCHAR(255) NOT NULL
);

CREATE TABLE passwords(
    password_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    password_value VARCHAR(255) NOT NULL
);

CREATE TABLE users(
    user_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_login VARCHAR(255) NOT NULL,

    personal_info_id INTEGER    REFERENCES personal_info (personal_info_id),
    password_id INTEGER         REFERENCES passwords (password_id)
);

CREATE TABLE accounts(
    account_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    account_name VARCHAR(255),

    user_id INTEGER             REFERENCES users (user_id)
);

CREATE TABLE credit_cards(
    credit_card_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    credit_card_name VARCHAR(255),
    credit_card_amount REAL NOT NULL DEFAULT 0,

    currency_id INTEGER         REFERENCES currencies_classifier (currency_id),
    account_id INTEGER          REFERENCES accounts (account_id)
);

CREATE TABLE purchases(
    purchase_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    purchase_date timestamp NOT NULL DEFAULT NOW(),
    purchase_amount REAL NOT NULL,
    purchase_comment VARCHAR(255),

    category_id INTEGER         REFERENCES categories_classifier(category_id),
    subcategory_id INTEGER      REFERENCES subcategories_classifier(subcategory_id),
    user_id INTEGER             REFERENCES users(user_id)
);

CREATE TABLE investments(
    investment_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    investment_date timestamp NOT NULL DEFAULT NOW(),
    investment_amount REAL NOT NULL,
    investment_comment VARCHAR(255),

    category_id INTEGER         REFERENCES categories_classifier(category_id),
    subcategory_id INTEGER      REFERENCES subcategories_classifier(subcategory_id)
);

CREATE TABLE incomes(
    income_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    income_date timestamp NOT NULL DEFAULT NOW(),
    income_amount REAL NOT NULL,
    income_comment VARCHAR(255),

    category_id INTEGER         REFERENCES categories_classifier(category_id),
    subcategory_id INTEGER      REFERENCES subcategories_classifier(subcategory_id),
    account_id INTEGER          REFERENCES accounts(account_id)
);

ALTER TABLE categories_classifier RENAME TO categories;
ALTER TABLE subcategories_classifier RENAME TO subcategories;

ALTER TABLE investments
    ADD COLUMN user_id INTEGER;
    
    
ALTER TABLE investments
    ADD CONSTRAINT investments_user_fkey FOREIGN KEY (user_id) REFERENCES users (user_id);

ALTER TABLE categories
    ADD COLUMN user_id INTEGER;
    
ALTER TABLE categories
    ADD CONSTRAINT categories_user_fkey FOREIGN KEY (user_id) REFERENCES users (user_id);

ALTER TABLE subcategories
    ADD COLUMN user_id INTEGER;
    
ALTER TABLE subcategories
    ADD CONSTRAINT subcategories_user_fkey FOREIGN KEY (user_id) REFERENCES users (user_id);

ALTER TABLE passwords
    ADD COLUMN user_id INTEGER;
    
ALTER TABLE passwords
    ADD CONSTRAINT passwords_user_fkey FOREIGN KEY (user_id) REFERENCES users (user_id);

ALTER TABLE personal_info
    ADD COLUMN user_id INTEGER;
ALTER TABLE personal_info 
	add column is_paid_user BOOLEAN
    
ALTER TABLE personal_info
    ADD CONSTRAINT personal_info_user_fkey FOREIGN KEY (user_id) REFERENCES users (user_id);

ALTER TABLE categories
    ADD COLUMN categories_classifier_id INTEGER;
    
ALTER TABLE categories
    ADD CONSTRAINT categories_classifier_categories_fkey 
        FOREIGN KEY (categories_classifier_id) 
        REFERENCES categories_classifier (categories_classifier_id);

ALTER TABLE purchases RENAME TO expenses;
ALTER TABLE personal_info
    ADD COLUMN personal_info_login VARCHAR(255);
              
ALTER TABLE expenses
    RENAME purchase_comment TO expense_comment;

ALTER TABLE passwords
   DROP CONSTRAINT passwords_user_fkey, 
   ADD  CONSTRAINT passwords_user_fkey
   FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE;

ALTER TABLE users
    DROP COLUMN IF EXISTS personal_info_id;

-- Generation new user
BEGIN;
    INSERT INTO users (user_login)
    VALUES ('maksfray51');

    INSERT INTO passwords (password_value, user_id)
    VALUES ('12345', 1);

    INSERT INTO personal_info (first_name, last_name, phone, email, user_id)
    VALUES ('Stas', 'Poltavets', '89113367279', 'sp20082002@gmail.com', 1);
COMMIT;

INSERT INTO categories_classifier(categories_classifier_name)
VALUES ('Доходы'), ('Расходы');
TRUNCATE TABLE categories RESTART IDENTITY CASCADE;

INSERT INTO categories(category_name, user_id, categories_classifier_id)
VALUES  ('Повседневные', 1, 2),
        ('Квартира', 1, 2),
        ('Крупные', 1, 2),
        ('Инвестиции', 1, 2),
        ('Отпуск', 1, 2);

INSERT INTO categories(category_name, user_id, categories_classifier_id)
VALUES  ('Работа', 1, 1),
        ('Инвестиции', 1, 1),
        ('Side Hustle', 1, 1),
        ('Универ', 1, 1);

INSERT INTO subcategories (
    subcategory_name,
    category_id,
    user_id
  )
VALUES ('Стипендия', 9, 1),
        ('Рублёвый вклад Tinkoff', 7, 1),
        ('MeetUp', 6, 1),
        ('МШП', 6, 1),
        ('Умскул', 6, 1),
        ('Техноскул', 6, 1);

/* Транзакция */
BEGIN;
    TRUNCATE TABLE credit_cards RESTART IDENTITY CASCADE;

    TRUNCATE TABLE accounts RESTART IDENTITY CASCADE;

    INSERT INTO accounts(account_name, user_id)
    VALUES ('Tinkoff', 1),
            ('Sber', 1);

    INSERT INTO credit_cards(credit_card_name, credit_card_amount, 
                        currency_id, account_id)
    VALUES ('tinkoff_main', 10000, 1, 1),
        ('tinkoff_moneybox', 10000, 1, 1),
        ('sber_main', 10000, 1, 2);
COMMIT;

INSERT INTO currencies_classifier(currency_name)
VALUES ('RUB'), ('EUR'), ('USD');

SET datestyle = mdy;

DELETE FROM expenses
SELECT c.relname FROM pg_class c WHERE c.relkind = 'S';

ALTER SEQUENCE purchases_purchase_id_seq RESTART WITH 1

COPY expenses FROM 'E:\UNIVERSITY\5th_sem\Database\Course paper\new_expenses.csv' 
    DELIMITER ';' CSV HEADER; 

COPY incomes FROM 'E:\UNIVERSITY\5th_sem\Database\Course paper\incomes.csv' 
    DELIMITER ',' CSV HEADER;   


--- СОЗДАЁМ РОЛИ ---

CREATE ROLE admin WITH
	LOGIN
	SUPERUSER
	INHERIT
	CREATEDB
	CREATEROLE
	NOREPLICATION;

COMMENT ON ROLE admin IS 'Админ базы данных';

-- 2 пользователя (платная подписка и бесплатная)

CREATE ROLE default_user WITH
	NOLOGIN
	NOSUPERUSER
	NOINHERIT
	NOCREATEDB
	NOCREATEROLE
	NOREPLICATION;
COMMENT ON ROLE default_user IS 'Обычный пользователь';


CREATE ROLE paid_user WITH
	NOLOGIN
	NOSUPERUSER
	NOINHERIT
	NOCREATEDB
	NOCREATEROLE
	NOREPLICATION;
COMMENT ON ROLE paid_user IS 'Пользователь с подпиской';


-- Раздаём привелегии ролям
GRANT ALL ON DATABASE "income_and_expenses" TO postgres, admin;
GRANT TEMPORARY, CONNECT ON DATABASE "income_and_expenses" TO PUBLIC;
GRANT CONNECT ON DATABASE "income_and_expenses" TO paid_user, default_user;


-- Раздаём привелегии для таблиц
GRANT ALL ON TABLE 
    expenses, 
    categories, 
    subcategories,  
    personal_info, 
    accounts, 
    credit_cards, 
    incomes, 
    investments,
    categories_classifier,
    currencies_classifier
TO admin, postgres;

GRANT SELECT ON TABLE
    categories_classifier,
    currencies_classifier
TO default_user, paid_user;

GRANT UPDATE, DELETE, INSERT, SELECT  ON TABLE 
    expenses, 
    categories, 
    subcategories,  
    personal_info, 
    accounts, 
    credit_cards, 
    incomes
TO default_user, paid_user;

GRANT UPDATE, DELETE, INSERT, SELECT  ON TABLE 
    investments
TO paid_user;

GRANT ALL ON TABLE 
    categories_classifier, 
    currencies_classifier, 
    passwords, 
    users
TO admin;

CREATE ROLE maksfray51 WITH LOGIN PASSWORD '12345';
GRANT paid_user TO maksfray51;


-- Добваление нового пользователя

CALL create_user('test_1', 'test_1@mail.ru', '555')

CREATE OR REPLACE PROCEDURE create_user(
  login text,
  email text,
  password text,
  first_name_from_form text,
  last_name_from_form text,
  phone text)
LANGUAGE plpgsql
AS $$
DECLARE 
    user_number INTEGER;
BEGIN
    -- Проверочка на то, чтобы мы не добавляли тех, кто уже есть
    IF (SELECT COUNT(*) FROM pg_roles WHERE rolname=login) THEN 
        RAISE EXCEPTION 'Такой прекрасный человек уже есть в нашей БД';
    ELSE 
        -- Добавляем пользователя в таблицу users
        EXECUTE format('INSERT INTO users(user_login)
                        VALUES (%L);', login);
        -- Заполняем пароли
        user_number := 	(SELECT user_id FROM users WHERE user_login=login);
        EXECUTE format('INSERT INTO passwords(password_value, user_id)
                    VALUES(%L, %L);', password, user_number);
        
        -- Добавляем персональную информацию о пользователе
        EXECUTE format('INSERT INTO personal_info (first_name, last_name, phone, email, user_id, personal_info_login, is_paid_user)
            VALUES (%L, %L, %L, %L, %L, %L, FALSE);', first_name_from_form, last_name_from_form, phone, email, user_number, login);
                        
    -- Почему %L? Всё очень просто. Есть 3 типа форматов: 
    -- S, I и L. Если S, то форматирует в виде обычной строки. I - идентификатор
    -- L - как SQL литерал (или как значение, которое мы вносим в таблицу проще говоря)
    -- Доп. ссылочка вот: https://www.postgresql.org/docs/current/functions-string.html#FUNCTIONS-STRING-FORMAT                    
                        
        -- Тут мы создаём роль для нашего пользователя с его логином и паролем 
        EXECUTE format('CREATE ROLE %I WITH LOGIN PASSWORD %L;', login, password);
        EXECUTE format('GRANT default_user TO %I;', login);
    END IF;
END; 
$$;
ALTER PROCEDURE create_user(text, text, text, text, text)
	OWNER TO admin;
GRANT EXECUTE ON PROCEDURE create_user(text, text, text, text, text) TO PUBLIC, admin, default_user;


-- Добавления нового расхода

-- Была нарушена последовательность для первичного ключа у expenses. Пришлось переписывать
SELECT c.relname FROM pg_class c WHERE c.relkind = 'S';
SELECT MAX(expense_id) FROM expenses;   
SELECT nextval('purchases_purchase_id_seq');
SELECT setval('purchases_purchase_id_seq', (SELECT MAX(expense_id) FROM expenses)+1);

CALL add_expense('2022-11-21', 450, 'стрижка', 'Повседневные', 'Регулярные', 1)
CREATE OR REPLACE PROCEDURE add_expense(
    date_expense timestamp,
    amount REAL,
    comment VARCHAR(255),
    category TEXT,
    subcategory TEXT,
    user_number INTEGER
) AS $$
    DECLARE
        category_number INTEGER;
        subcategory_number INTEGER;
    BEGIN
        SELECT 
            category_id INTO category_number
        FROM 
            categories 
        WHERE 
            category_name = category;

        SELECT 
            subcategory_id INTO subcategory_number
        FROM 
            subcategories 
        WHERE 
            subcategory_name = subcategory;

        -- category_number := EXECUTE format('SELECT category_id FROM categories WHERE category_name = %L', category);
        -- subcategory_number := (SELECT subcategory_id FROM subcategories WHERE subcategory_name = format('%S', subcategory));

        EXECUTE format('INSERT INTO expenses (expense_date, expense_amount, expense_comment,
                                                category_id, subcategory_id, user_id)
                        VALUES(%L, %L, %L, %L, %L, %L);', date_expense, amount, comment, 
                                                            category_number, subcategory_number, user_number);
    END; $$
LANGUAGE plpgsql;
ALTER PROCEDURE add_expense(timestamp, REAL, VARCHAR(255), text, text, integer)
	OWNER TO admin;
GRANT EXECUTE ON PROCEDURE add_expense(timestamp, REAL, VARCHAR(255), text, text, integer) TO PUBLIC, admin, default_user, paid_user;


-- Добавления нового дохода

CREATE OR REPLACE PROCEDURE add_income(
    date_income timestamp,
    amount REAL,
    comment VARCHAR(255),
    category TEXT,
    subcategory TEXT,
    user_number INTEGER
) AS $$
    DECLARE
        category_number INTEGER;
        subcategory_number INTEGER;
        account_number INTEGER;
    BEGIN
        SELECT 
            category_id INTO category_number
        FROM 
            categories 
        WHERE 
            category_name = category;

        SELECT 
            subcategory_id INTO subcategory_number
        FROM 
            subcategories 
        WHERE 
            subcategory_name = subcategory;

        SELECT
            account_id INTO account_number
        FROM
            accounts
        WHERE
            accounts.user_id = user_number;

        EXECUTE format('INSERT INTO incomes (income_date, income_amount, income_comment,
                                                category_id, subcategory_id, account_id)
                        VALUES(%L, %L, %L, %L, %L, %L);', date_income, amount, comment, 
                                                            category_number, subcategory_number, account_number);
    END; $$
LANGUAGE plpgsql;

ALTER PROCEDURE add_income(timestamp, REAL, VARCHAR(255), text, text, integer)
	OWNER TO admin;
GRANT EXECUTE ON PROCEDURE add_income(timestamp, REAL, VARCHAR(255), text, text, integer) TO PUBLIC, admin, default_user, paid_user;


-- Та же тема с последовательностью. Была нарушена последовательность для первичного ключа у incomes. Пришлось переписывать
SELECT c.relname FROM pg_class c WHERE c.relkind = 'S';
SELECT MAX(income_id) FROM incomes;   
SELECT nextval('incomes_income_id_seq');
SELECT setval('incomes_income_id_seq', (SELECT MAX(income_id) FROM incomes)+1);

-- Проверяем работу
CALL add_income('2022-11-23', 17637, 'стипа за несколько месяцев', 'Универ', 'Стипендия', 1)


-- Процедура добавляения новой инвестиции
CREATE OR REPLACE PROCEDURE add_investment(
    date_investment timestamp,
    amount REAL,
    comment VARCHAR(255),
    subcategory TEXT,
    user_login  TEXT
) AS $$
    DECLARE
        subcategory_number INTEGER;
        user_number INTEGER;
    BEGIN
        SELECT 
            subcategory_id INTO subcategory_number
        FROM 
            subcategories 
        WHERE 
            subcategory_name = subcategory;

        SELECT
            user_id INTO user_number
        FROM
            personal_info
        WHERE
            personal_info_login = user_login;

        EXECUTE format('INSERT INTO investments (investment_date, investment_amount, investment_comment,
                                                category_id, subcategory_id, user_id)
                        VALUES(%L, %L, %L, %L, %L, %L);', date_investment, amount, comment, 
                                                            7, subcategory_number, user_number);
    END; $$
LANGUAGE plpgsql;

ALTER PROCEDURE add_investment(timestamp, REAL, VARCHAR(255), text, text)
	OWNER TO admin;
GRANT EXECUTE ON PROCEDURE add_investment(timestamp, REAL, VARCHAR(255), text, text) TO admin, paid_user;

-- Проверяем работу
CALL add_investment('2021-04-02', 1000, 'рубли', 'Валюта', 'maksfray51')

/*Индексация*/

-- индексация для expenses
CREATE INDEX expenses_date_index ON expenses(expense_date);
CREATE INDEX expenses_amount_index ON expenses(expense_amount);

-- индексация для incomes
CREATE INDEX incomes_date_index ON incomes(income_date);
CREATE INDEX incomes_amount_index ON incomes(income_amount);

/* Представления (VIEW) */

--  1) Последние операции (доходы расходы через union)
CREATE VIEW all_transactions AS
    SELECT
        expense_date as our_date,
        expense_amount as our_amount,
        expense_comment as expense_comment,
        subcategory_name as subcategory,
        category_name as category
    FROM 
        expenses
        INNER JOIN subcategories ON expenses.subcategory_id = subcategories.subcategory_id
        INNER JOIN categories ON expenses.category_id = categories.category_id

    UNION

    SELECT
        income_date as our_date,
        income_amount as our_amount,
        income_comment as expense_comment,
        subcategory_name as subcategory,
        category_name as category
    FROM 
        incomes
        INNER JOIN subcategories ON incomes.subcategory_id = subcategories.subcategory_id
        INNER JOIN categories ON incomes.category_id = categories.category_id

    ORDER BY
        our_date DESC;

/*Функции*/
-- Функция для изменения категории в доходах или расходах
CREATE OR REPLACE FUNCTION change_category(
	transaction_number integer,
	new_category_name TEXT,
    is_expense BOOLEAN
) RETURNS TEXT COST 100 VOLATILE PARALLEL UNSAFE
AS $change_category$
    DECLARE
        expense_category_id INTEGER;
        income_category_id INTEGER;
    BEGIN
        IF (is_expense = TRUE)
        THEN
            SELECT 
                category_id INTO expense_category_id
            FROM 
                categories 
            WHERE 
                category_name = new_category_name;   

            UPDATE
                expenses
            SET
                category_id = expense_category_id
            WHERE
                expense_id = transaction_number;

            RETURN (
                SELECT 
                    category_name 
                FROM 
                    expenses
                    INNER JOIN categories ON expenses.category_id = categories.category_id
                WHERE 
                    expense_id = transaction_number
            );
        ELSE
            SELECT 
                category_id INTO income_category_id
            FROM 
                categories 
            WHERE 
                category_name = new_category_name; 

            UPDATE
                incomes
            SET
                category_id = income_category_id
            WHERE
                income_id = transaction_number;

            RETURN (
                SELECT 
                    category_name 
                FROM 
                    incomes
                    INNER JOIN categories ON incomes.category_id = categories.category_id
                WHERE 
                    income_id = transaction_number
            );
        END IF;
    END;
$change_category$ LANGUAGE plpgsql;

ALTER FUNCTION change_category(integer, text, BOOLEAN)
	OWNER TO admin;
GRANT EXECUTE ON FUNCTION change_category(integer, text, BOOLEAN) TO PUBLIC, admin, ordinary_worker;

-- триггерная функция
CREATE OR REPLACE FUNCTION delete_user_role() 
RETURNS trigger
AS $body$
BEGIN
  EXECUTE format('DROP ROLE %I', OLD.user_login);
  RETURN NULL;
END; $body$
LANGUAGE plpgsql;

CREATE TRIGGER delete_user_role_trigger
	AFTER DELETE ON users
	FOR EACH ROW
	EXECUTE FUNCTION delete_user_role();

-- проверка
DELETE FROM users WHERE user_login = 'test1'

INSERT INTO accounts (account_name, user_id)
VALUES  ('Sber', 1), 
        ('SDM Bank', 1);

INSERT INTO credit_cards (credit_card_name, credit_card_amount, currency_id, account_id)
VALUES ('tinkoff_financial_cushion_usd', 0.02, 3, 1),
        ('tinkoff_financial_cushion_eur', 219.45, 2, 1),
        ('sber_gold', 10000, 1, 1),
        ('sdm_main', 0, 1, 1);

INSERT INTO subcategories (subcategory_name, category_id, user_id)
VALUES ('Валюта', 7, 1),
        ('Акции', 7, 1),
        ('Бизнес.Товарка', 7, 1);

-- 29 валюта, 30 Акции, 31 Бизнес.Товарка
INSERT INTO investments (investment_date, investment_amount, 
                        investment_comment, category_id, 
                        subcategory_id, user_id)
VALUES ('2020-12-09', 1500, 'баксы', 7, 29, 1),
        ('2020-10-14', 1827, 'евро', 7, 29, 1),
        ('2020-10-20', 15732, 'баксы+евро', 7, 29, 1),
        ('2020-11-07', 3267, 'рубли', 7, 29, 1),
        ('2020-11-07', 1174, 'ВТБ, СБЕР', 7, 30, 1),
        ('2020-12-04', 6581, 'баксы, евро, рубли', 7, 29, 1),
        ('2021-01-04', 12300, 'баксы, евро, рубли', 7, 29, 1),
        ('2021-02-07', 6001, 'баксы, евро, рубли', 7, 29, 1),
        ('2021-03-06', 5010, 'баксы, евро, рубли', 7, 29, 1),
        ('2021-11-12', 82000, 'баксы, евро, рубли', 7, 29, 1),
        ('2022-07-29', 65600, 'баксы, евро, рубли', 7, 29, 1);
